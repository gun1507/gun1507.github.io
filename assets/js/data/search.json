[ { "title": "컨테이너(Container), 도커(Docker)와 쿠버네티스(k8s)는 무엇일까?", "url": "/posts/docker-k8s_2/", "categories": "Kubernetes", "tags": "Java, Docker, Kubernetes, k8s, DevOps, MSA", "date": "2023-08-11 13:00:00 +0900", "snippet": " 컨테이너, 도커, 쿠버네티스 컨테이너 컨테이너는 가상머신을 사용해 각 마이크로 서비스를 격리(islate)하는 기술 컨테이너는 가상머신처럼 하드웨어를 전부 구현하지 않기 때문에 빠른 실행 가능 구동하려는 애플리케이션을 실행할 수 있는 환경까지 감싸서(이미지), 어디서든 쉽게 실행할 수 있도록 해주는 기술 컨테이너 격리 기술에는 리눅스 네임 스페이스(namespace), 리눅스 컨트롤 그룹(cgroups) 와 유니온 파일 시스템(Union mount file system)이 있다. Traditional Deployment : 클라우드 컴퓨팅 기술이 나오기 전까지 인프라 구축의 일반적인 방식 Virtualized Deployment : 가상환경을 사용하는 방식(VM에 운영체제가 있고 하드웨어를 가상화로 구현하는 특징을 갖고 있기 때문에 무겁다) Container Deployment : Hyperviser를 통해 가상환경을 구축할 필요 없으며, 운영체제 또한 구축할 필요가 없어 리소스가 적다. 리눅스 네임 스페이스 각 프로세스별로 별도의 커널 자원(네트워크, 유저, 호스트 네임 등)을 분할하는 리눅스 커널의 기능 커널 자원을 분할 지원하는 기능 리눅스 컨트롤 그룹 각 프로세스별 소비할 수 있는 리소스 양(CPU, 메모리, I/O, 네트워크 대역대,device 노드 등)을 수집, 제한, 격리시키는 기능 도커 컨테이너 : 이미지를 격리하여 독립된 공간에서 실행한 가상 환경 이미지 : 필요한 프로그램과 라이브러리, 소스를 설치한 뒤 만든 하나의 파일 새로운 도커 컨테이너를 설치하기 위한 것 (사용자 입맛대로 설정) 운영체제가 필요한 경우 (우분투, 센토스 등) 어플리케이션이 필요한 경우 (톰캣, MySQL 등) 이미지 다운로드 및 설치 -&amp;gt; 컨테이너 생성 이러한 컨테이너 기술을 지원해주는 도커 출처 : https://gngsn.tistory.com/128 Docker engine: 이미지, 네트워크, 디스크 등의 관리 역할Containerd : runC를 이용한 container를 관리해주는 daemonrunC : 필요한 구성요소를 할당하고 container를 격리, 생성 시켜주는 역할shim : container의 생명주기 관리를 해주는 역할💡 각각 돌아가기 때문에 Docker Engine을 재실행 해도 각 이미지에 영향이 없다. 도커의 한계 서비스가 커지면 커질 수록 관리해야 하는 컨테이너의 양이 급격히 증가 때문에 도커를 관리할 수 있는 쿠버네티스가 탄생 쿠버네티스 다수의 컨테이너를 자동으로 운영하기 위한 오케스트레이션 도구 컨테이너 분산 배치, 컨테이너 교체, 컨테이너 환경 설정을 관리 클라우드 네이티브를 가장 효과적으로 구현하기 위한 도구로 DevOps, MSA와 관련이 있다. 쿠버네티스의 장점 컨테이너 오케스트레이션 비용 절감 MSA를 위한 데브옵스 효율성 향상 멀티 클라우드 환경에서 워크로드 배포 용이 종속 가능성 없는 이식성 제고 배포 자동화 및 확장성 강화 클라우드 환경에서의 앱 안정성 및 가용성 강화 오픈소스 생태계의 일부로서 이용하기 편리" }, { "title": "도커(Docker)와 쿠버네티스(Kubernetes)는 왜 사용해야 할까?", "url": "/posts/docker-k8s_1/", "categories": "Kubernetes", "tags": "Java, Docker, Kubernetes, k8s, DevOps, MSA", "date": "2023-08-10 11:52:00 +0900", "snippet": " 모놀리식 아키텍처와 마이크로서비스의 아키텍처 모놀리식 아키텍처에서 마이크로서비스 아키텍처로 변경되며 많은 단점을 보완하기 위함입니다.모놀리식 아키텍처의 경우 프로세스가 결합되어 있고 단일 서비스로 실행되는 전통적인 방식입니다.이러한 특징을 갖고있기 때문에 코드베이스가 증가하게 되면 기능을 추가하거나 개선하기 복잡해집니다.마이크로서비스 아키텍처의 경우 애플리케이션이 독립적인 구성 요소로 구축되어 각 애플리케이션 프로세스가 서비스로 실행됩니다.서비스가 독립적으로 실행되기 때문에 애플리케이션의 특정 기능에 대한 수요를 충족하도록 각 서비스를 업데이트, 배포 및 확장할 수 있습니다. 출처 : https://aws.amazon.com/ko/microservices 모놀리식 아키텍처 전통적인 아키텍처, 기존에 사용하던 서비스 방법 서비스가 하나의 애플리케이션으로 돌아가는 구조 기존의 개발 방식을 사용해 개발하여 간단히 배포 하나의 서비스 또는 어플리케이션이 하나의 거대한 아키텍처 다양한 기능을 동작하는 서비스를 서버에서 실행하여 서비스 마이크로서비스 아키텍처의 장점 하나의 애플리케이션으로 구성되어있어 테스트 용이 빠르고 간단한 서비스 개발 모놀리식 아키텍처 단점 기존의 애플리케이션을 그대로 복제하여 로드밸런싱 불필요한 서비스까지 모두 복제 각 기능에 따른 라이브러리를 매번 업데이트 하기에 관리가 어려움(라이브러리의 충돌) 조금만 수정해도 전체 빌드 및 배포 필요 마이크로서비스 아키텍처 모놀리식 아키텍처의 대안으로 반대되는 개념 애플리케이션의 각각의 기능을 분리하여 개발 및 관리 분산 시스템 환경에서 Transaction 보장, 테스트, 배포, 관리 복잡 마이크로서비스 아키텍처의 장점 서비스 단위 빠른 개발 : 개발자가 특정 비즈니스 로직에 대해서만 집중하여 개발 가능 배포 용이 : 개별 서비스 단위로 개발, 패키징 빌드, 테스트, 배포로 각 서비스마다 유연하게 작용 서비스 단위 고효율 저비용 Scale-Out 구조 : 서비스 단위로 스케일링이 가능하여 불필요한 서비스는 줄이고 더 많은 자원이 필요한 서비스는 확장 가능 서비스 단위로 스케일링이 가능하여 불필요한 서비스는 줄이고 더 많은 자원이 필요한 서비스는 확장가능 마이크로서비스 아키텍처 단점 분산 시스템 환경에서 Transaction 보장, 테스트, 배포, 관리 복잡 정리 마이크로서비스의 분산 시스템 환경에서 Transaction 보장, 테스트, 배포, 관리 복잡한 문제를 해결하기 위해 이미지, 컨테이너, 도커와 쿠버네티스를 사용합니다.다음 내용에서 이미지, 컨테이너, 도커와 쿠버네티스의 내용에 대해 살펴보겠습니다." }, { "title": "Jxls merge cell 동적 병합 구현(each-merge, each-merge-single)", "url": "/posts/jxls-merge_1/", "categories": "Java, Jxls", "tags": "Java, Jxls, Poi, Excel, chirpy", "date": "2023-07-13 14:20:00 +0900", "snippet": " Jxls Jxls 는 미리 엑셀 템플릿을 만들어두고 데이터를 템플릿에 바인딩한 후 결과를 엑셀로 받게끔 처리해주는 라이브러리입니다.엑셀 템플릿에 데이터 바인딩 할 때의 문법은 Jstl 과 매우 유사하기 때문에 Jstl 을 다뤄봤다면 조금 더 접근하기 쉽습니다. Jxls 를 사용하며 가장 어려웠던 부분은 동적 병합 이었습니다. 때문에 두 custom 합수가 나오게 되었습니다.each-merge 와 each-merge-single 은 특징이 서로 다른 함수이기 때문에 각각 설명을 하겠습니다. each-merge each-merge 는 부모-자식의 관계로 동적 병합이 이루어지는 함수입니다. json 파일로 예를 들어보겠습니다.{ &quot;schoolList&quot; : [ { &quot;name&quot; : &quot;특목고&quot;, &quot;groupList&quot; : [ { &quot;name&quot; : &quot;과학&quot;, &quot;nameList&quot; : [ { &quot;name&quot; : &quot;강바영&quot;, &quot;score&quot; : 54 }, { &quot;name&quot; : &quot;윤사은&quot;, &quot;score&quot; : 65 }, { &quot;name&quot; : &quot;장아린&quot;, &quot;score&quot; : 98 }, { &quot;name&quot; : &quot;한자윤&quot;, &quot;score&quot; : 69 }, { &quot;name&quot; : &quot;배찬영&quot;, &quot;score&quot; : 80 } ] }, { &quot;name&quot; : &quot;외국어&quot;, &quot;nameList&quot; : [ { &quot;name&quot; : &quot;오태현&quot;, &quot;score&quot; : 79 }, { &quot;name&quot; : &quot;김파은&quot;, &quot;score&quot; : 88 }, { &quot;name&quot; : &quot;이하린&quot;, &quot;score&quot; : 89 }, { &quot;name&quot; : &quot;박건우&quot;, &quot;score&quot; : 38 }, { &quot;name&quot; : &quot;최경민&quot;, &quot;score&quot; : 78 } ] }, { &quot;name&quot; : &quot;국제&quot;, &quot;nameList&quot; : [ { &quot;name&quot; : &quot;김두리&quot;, &quot;score&quot; : 77 }, { &quot;name&quot; : &quot;이미주&quot;, &quot;score&quot; : 78 }, { &quot;name&quot; : &quot;박바다&quot;, &quot;score&quot; : 99 }, { &quot;name&quot; : &quot;장서연&quot;, &quot;score&quot; : 18 }, { &quot;name&quot; : &quot;김수아&quot;, &quot;score&quot; : 98 } ] } ] } ]}위 json 파일의 경우 자식 항목의 갯수 만큼 병합 시켜야 하고 결과는 아래와 같이 나옵니다. each-merge Template each-merge 함수를 사용한 템플릿과 함수입니다. jx:area(lastCell=”Z999”) 는 Z:999 의 범위까지 템플릿의 영역 이라는 것을 나타낸다. jx:each-merge(items=”schools” var=”school” lastCell=”D3”) 는 schools 의 리스트를 반복할 것이며, 리스트 내의 자식은 school 으로 사용하고 A:3 부터 D:3 까지 템플릿의 영역 이라는 것을 나타낸다. 2번과 마찬가지로 school의 groupList 를 반복할 것이며, 리스트 내의 자식은 group 으로 사용하고 B:3 부터 D:3 까지 템플릿의 영역 이라는 것을 나타낸다. group의 nameList 를 반복할 것이며, 리스트 내의 자식은 name 으로 사용하고 C:3 부터 D:3 까지 템플릿의 영역 이라는 것을 나타낸다. 💡 A:3 부터 D:3 까지 셀에 작성되어 있는 ${school.name} 의 형태는 자식 객체(school)가 갖고있는 항목 중 name을 반복하겠다는 의미입니다. each-merge 구현 EachMergeCommand public class EachMergeCommand extends EachCommand { public static final String COMMAND_NAME = &quot;each-merge&quot;; @Override public Size applyAt(CellRef cellRef, Context context) { // each-merge 셀 의 하위 셀 영역 목록을 가져온다. List&amp;lt;Area&amp;gt; childAreas = this.getAreaList().stream() .flatMap(area -&amp;gt; area.getCommandDataList().stream()) .flatMap(commandData -&amp;gt; commandData.getCommand().getAreaList().stream()) .collect(Collectors.toList()); // 셀 병합을 수행하는 MergeAreaListener instance 생성 MergeAreaListener listener = new MergeAreaListener(this.getTransformer(), cellRef); // each-merge comment 가 작성된 cell area 에 MergeAreaListener 추가 this.getAreaList().get(0).addAreaListener(listener); // 하위 영역에 MergeAreaListener 추가 childAreas.forEach(childArea -&amp;gt; { childArea.addAreaListener(listener); }); // each 커맨드 수행 return super.applyAt(cellRef, context); }}엑셀 내에 each-merge 함수가 있는 경우 사용하며, 한번의 each-merge 를 진행할 때마다 MergeAreaListener 생성자를 호출합니다. MergeAreaListener public class MergeAreaListener implements AreaListener { private final CellRef commandCell; private final Sheet sheet; private CellRef lastRowCellRef; public MergeAreaListener(Transformer transformer, CellRef cellRef) { this.commandCell = cellRef; this.sheet = ((PoiTransformer) transformer).getXSSFWorkbook().getSheet(cellRef.getSheetName()); } @Override public void afterApplyAtCell(CellRef cellRef, Context context) { // child cell if (commandCell.getCol() != cellRef.getCol()) { this.setLastRowCellRef(cellRef); } else { if (existMerged(cellRef)) { return; } merge(cellRef); } } private void merge(CellRef cellRef) { if(this.lastRowCellRef == null) return; int from = cellRef.getRow(); int lastRow = sheet.getMergedRegions().stream() .filter(address -&amp;gt; address.isInRange(this.lastRowCellRef.getRow(), this.lastRowCellRef.getCol())) .mapToInt(CellRangeAddressBase::getLastRow).findFirst().orElse(this.lastRowCellRef.getRow()); log.debug(&quot;this :{}, merged start row : {} | end row : {} | col :{} &quot;, this.toString(), from, lastRow, cellRef.getCol()); CellRangeAddress region = new CellRangeAddress(from, lastRow, cellRef.getCol(), cellRef.getCol()); sheet.addMergedRegion(region); applyStyle(sheet.getRow(cellRef.getRow()).getCell(cellRef.getCol())); } private void setLastRowCellRef(CellRef cellRef) { if (this.lastRowCellRef == null || this.lastRowCellRef.getRow() &amp;lt; cellRef.getRow()) { this.lastRowCellRef = cellRef; } } private void applyStyle(Cell cell) { CellStyle cellStyle = cell.getCellStyle(); cellStyle.setAlignment(HorizontalAlignment.CENTER); cellStyle.setVerticalAlignment(VerticalAlignment.CENTER); } @Override public void beforeApplyAtCell(CellRef cellRef, Context context) { } @Override public void beforeTransformCell(CellRef srcCell, CellRef targetCell, Context context) { } @Override public void afterTransformCell(CellRef srcCell, CellRef targetCell, Context context) { } private boolean existMerged(CellRef cell) { return sheet.getMergedRegions().stream() .anyMatch(address -&amp;gt; address.isInRange(cell.getRow(), cell.getCol())); }}실제 병합이 이루어지는 함수 구현이 되어 있습니다. AreaListener 를 상속받아 afterApplyAtCell 을 재정의 했습니다.자식의 항목 갯수만큼 반복하며 첫 번째 셀부터 마지막 셀까지 병합을 진행합니다. each-merge-single each-merge-single 는 단일 리스트가 동적으로 병합이 이루어지는 함수입니다. json 파일로 예를 들어보겠습니다.{ &quot;passList&quot; : [ { &quot;name&quot; : &quot;불합격&quot; }, { &quot;name&quot; : &quot;불합격&quot; }, { &quot;name&quot; : &quot;합격&quot; }, { &quot;name&quot; : &quot;불합격&quot; }, { &quot;name&quot; : &quot;합격&quot; }, { &quot;name&quot; : &quot;합격&quot; }, { &quot;name&quot; : &quot;합격&quot; }, { &quot;name&quot; : &quot;합격&quot; }, { &quot;name&quot; : &quot;불합격&quot; }, { &quot;name&quot; : &quot;합격&quot; }, { &quot;name&quot; : &quot;합격&quot; }, { &quot;name&quot; : &quot;합격&quot; }, { &quot;name&quot; : &quot;합격&quot; }, { &quot;name&quot; : &quot;불합격&quot; }, { &quot;name&quot; : &quot;합격&quot; } ]}위 json 파일의 경우 하나의 리스트로 중복되는 문자마다 병합 시켜야 하고 결과는 아래와 같이 나옵니다. each-merge-single Template each-merge-single 함수를 사용한 템플릿과 함수입니다. jx:area(lastCell=”Z999”) 는 Z:999 의 범위까지 템플릿의 영역 이라는 것을 나타낸다. jx:each-merge-single(items=”passes” var=”pass” lastCell=”A3”) 는 passes 의 리스트를 반복할 것이며, 리스트 내의 자식은 pass 으로 사용하고 A:3 까지 템플릿의 영역 이라는 것을 나타낸다. varIndex 는 반복 색인을 보유하는 Jxls context의 변수 명이며 0부터 시작합니다. (반복 시 현재 index를 알기 위해 사용했습니다) 💡 A:3 에 작성되어 있는 ${pass.name} 의 형태는 객체(pass)가 갖고있는 항목 중 name을 반복하겠다는 의미입니다. each-merge-single 구현 EachMergeSingleCommand public class EachMergeSingleCommand extends EachCommand { public static final String COMMAND_NAME = &quot;each-merge-single&quot;; @Override public Size applyAt(CellRef cellRef, Context context) { // each-merge 셀 의 하위 셀 영역 목록을 가져온다. List&amp;lt;Area&amp;gt; childAreas = this.getAreaList().stream() .flatMap(area -&amp;gt; area.getCommandDataList().stream()) .flatMap(commandData -&amp;gt; commandData.getCommand().getAreaList().stream()) .collect(Collectors.toList()); // 셀 병합을 수행하는 MergeAreaListener instance 생성 MergeAreaSingleListener listener = new MergeAreaSingleListener(this.getTransformer(), cellRef, this.getItems()); // each-merge comment 가 작성된 cell area 에 MergeAreaListener 추가 this.getAreaList().get(0).addAreaListener(listener); // 하위 영역에 MergeAreaListener 추가 childAreas.forEach(childArea -&amp;gt; { childArea.addAreaListener(listener); }); // each 커맨드 수행 return super.applyAt(cellRef, context); }}엑셀 내에 each-merge-single 함수가 있는 경우 사용하며, 한번의 each-merge-single 를 진행할 때마다 MergeAreaSingleListener 생성자를 호출합니다. MergeAreaSingleListener public class MergeAreaSingleListener implements AreaListener { private final CellRef commandCell; private final Sheet sheet; private final String item; private CellRef lastRowCellRef; private XSSFWorkbook workbook; public MergeAreaSingleListener(Transformer transformer, CellRef cellRef, String item) { this.commandCell = cellRef; this.workbook = ((PoiTransformer) transformer).getXSSFWorkbook(); this.sheet = workbook.getSheet(cellRef.getSheetName()); this.item = item; } @Override public void afterApplyAtCell(CellRef cellRef, Context context) { List&amp;lt;String&amp;gt; object = (List&amp;lt;String&amp;gt;) context.getVar(item); int totalSize = object.size(); int curSize = (int) context.getVar(&quot;index&quot;); if(curSize + 1 == totalSize || !Objects.equals(object.get(curSize), object.get(curSize + 1))) { merge(cellRef); }else{ return; } } private void merge(CellRef cellRef) { // 병합이 시작될 지점 int from = this.lastRowCellRef == null ? commandCell.getRow() : this.lastRowCellRef.getRow() + 1; int lastRow = cellRef.getRow(); this.setLastRowCellRef(cellRef); log.debug(&quot;this :{}, merged start row : {} | end row : {} | col :{} &quot;, this.toString(), from, lastRow, cellRef.getCol()); if(from != lastRow) { // 병합 cell 생성 CellRangeAddress region = new CellRangeAddress(from, lastRow, cellRef.getCol(), cellRef.getCol()); // sheet 에 병합된 셀 추가 sheet.addMergedRegion(region); } // 스타일 적용 applyStyle(sheet.getRow(from).getCell(cellRef.getCol())); } private void setLastRowCellRef(CellRef cellRef) { if (this.lastRowCellRef == null || this.lastRowCellRef.getRow() &amp;lt; cellRef.getRow()) { this.lastRowCellRef = cellRef; } } private void applyStyle(Cell cell) { CellStyle cellStyle = null; Font font = workbook.createFont(); font.setColor(IndexedColors.WHITE.getIndex()); // 배경, 폰트 지정 if(cell.toString().equals(&quot;불합격&quot;)) { cellStyle = workbook.createCellStyle(); cellStyle.setFont(font); cellStyle.setFillForegroundColor(IndexedColors.RED.getIndex()); cellStyle.setFillPattern(FillPatternType.SOLID_FOREGROUND); }else if(cell.toString().equals(&quot;합격&quot;)) { cellStyle = workbook.createCellStyle(); cellStyle.setFont(font); cellStyle.setFillForegroundColor(IndexedColors.GREEN.getIndex()); cellStyle.setFillPattern(FillPatternType.SOLID_FOREGROUND); }else{ cellStyle = cell.getCellStyle(); } cellStyle.setAlignment(HorizontalAlignment.CENTER); cellStyle.setVerticalAlignment(VerticalAlignment.CENTER); cell.setCellStyle(cellStyle); } private boolean existMerged(CellRef cell) { return sheet.getMergedRegions().stream() .anyMatch(address -&amp;gt; address.isInRange(cell.getRow(), cell.getCol())); } @Override public void beforeApplyAtCell(CellRef cellRef, Context context) { } @Override public void beforeTransformCell(CellRef srcCell, CellRef targetCell, Context context) { } @Override public void afterTransformCell(CellRef srcCell, CellRef targetCell, Context context) { }}실제 병합이 이루어지는 함수 구현이 되어 있습니다. AreaListener 를 상속받아 afterApplyAtCell 을 재정의 했습니다.항목 갯수만큼 반복하며 다음 항목과 다른 문자열을 가진 경우 병합을 진행합니다.불합격인 경우 와 합격인 경우 폰트 색상과 배경색을 변경합니다. 참조 jxls-docs samhyun-blog Repository jxls-merge" }, { "title": "따라 하다 보면 쉬운 Github Blog 만들기_3", "url": "/posts/make-devlog_3/", "categories": "Blog, jekyll", "tags": "github.io, devlog, theme, repository, chirpy", "date": "2023-07-08 12:50:00 +0900", "snippet": " 세 번째 Step은 chirpy 테마를 적용할꺼에요😃chirpy 테마가 깔끔해서 선택했지만 다른 테마를 적용하셔도 무방합니다. chirpy 테마 다운로드 chirpy 테마가 아닌 다른 테마를 선택하고 싶다면 jekyllthemes.org 에서 선택해주세요.chirpy 테마를 다운받기 위해서 jekyll-theme-chirpy 에서 소스를 다운받겠습니다.테마 적용을 위해서 다운받은 소스는 이전 강의에서 clone했던 root 디렉토리에 복사+붙여넣기를 하겠습니다.저의 경우 ~/Workspace/gun1507-test.github.io 입니다.이름이 겹치는 파일들은 모두 덮어쓰기(대치) 하겠습니다. 로컬 환경에서 확인하기 적용한 chirpy 테마를 로컬에서 제대로 뜨는지 확인해보겠습니다.bundle exec jekyll serve Incremental build: disabled. Enable with --incremental Generating... Conflict: The following destination is shared by multiple files. The written file may end up with unexpected contents. /Users/Workspace/gun1507-test.github.io/_site/404.html - assets/404.html - 404.html Conflict: The following destination is shared by multiple files. The written file may end up with unexpected contents. /Users/Workspace/gun1507-test.github.io/_site/about/index.html - about.markdown - /Users/Workspace/gun1507-test.github.io/_tabs/about.md Conflict: The following destination is shared by multiple files. The written file may end up with unexpected contents. /Users/Workspace/gun1507-test.github.io/_site/index.html - index.html - index.markdown done in 0.769 seconds. 로컬에서 정상적으로 뜨긴 했지만, 위와 같은 오류가 발생했습니다.이름이 같은 파일이 있어 충돌이 났기 때문에 파일 삭제를 하겠습니다.rm -f 404.htmlrm -f about.markdownrm -f index.markdownConfiguration file: /Workspace/gun1507-test.github.io/_config.yml Theme Config file: /Workspace/gun1507-test.github.io/_config.yml Source: /Workspace/gun1507-test.github.io Destination: /Workspace/gun1507-test.github.io/_site Incremental build: disabled. Enable with --incremental Generating... done in 0.523 seconds. Auto-regeneration: enabled for &#39;/Workspace/gun1507-test.github.io&#39; Server address: http://127.0.0.1:4000/ Server running... press ctrl-c to stop. 정상적으로 로컬에 나온걸 알 수 있습니다. 배포하기 로컬에서는 정상 확인했지만 꼭 배포를 하면 오류가 났습니다.배포하기 전에 _config.yml 파일을 수정하겠습니다.lang: en -&amp;gt; kotimezone: Asia/Shanghai -&amp;gt; Asia/Seoultitle: Chirpy -&amp;gt; gun1507-test Blogtagline: A text-focused Jekyll theme -&amp;gt; chirpy 테마 테스트 블로그 입니다.url: &quot;&quot; -&amp;gt; &#39;https://gun1507-test.github.io&#39;github: username: github_username -&amp;gt; gun1507-test _config.yml 파일 수정 후에 add,commit,push를 진행합니다. 🔥만났던 오류🔥 deploy 과정에서의 오류 tools/deploy.sh 파일이 없다는 오류가 나타났습니다.bash: tools/deploy.sh: No such file or directoryError: Process completed with exit code 127.tools/deploy.sh 가 없기 때문에 제 저장소에서 다운로드 한 이후 복붙 해주세요!tools 전체를 복사 붙여넣기 하겠습니다. deploy 과정에서의 권한 오류 build 과정에서 fatal: unable to access &#39;https://github.com/gun1507-test/gun1507-test.github.io/&#39;: The requested URL returned error: 403 오류가 나타났습니다.Actions의 권한 문제라고 생각이 들어 github 접속 후 Actions Settings를 확인했습니다. repository -&amp;gt; settings -&amp;gt; Actions -&amp;gt; Workflow Permissions -&amp;gt; Read and write permissions읽기와 쓰기 모두 가능하도록 변경합니다." }, { "title": "따라 하다 보면 쉬운 Github Blog 만들기_2", "url": "/posts/make-devlog_2/", "categories": "Blog, jekyll", "tags": "github.io, devlog, theme, repository, chirpy", "date": "2023-06-26 21:36:00 +0900", "snippet": " 두 번째 Step은 로컬에 Jekyll을 띄우고 원격에 push까지 할꺼에요😃설치 순서는 순서는 rbenv &amp;gt; ruby &amp;gt; jekyll 입니다. Ruby 설치 ruby를 설치하기 전에 rbenv먼저 설치하겠습니다.rbenv는 루비 버전을 관리할 수 있는 툴입니다.brew install rbenv설치 가능한 버전을 확인해보겠습니다.저의 경우에는 3.2.2 버전을 다운받을 수 있어 3.2.2 버전을 다운받겠습니다.rbenv install -l3.0.63.1.43.2.2jruby-9.4.3.0mruby-3.2.0picoruby-3.0.0truffleruby-23.0.0truffleruby+graalvm-23.0.0rbenv install 3.2.2 Jekyll은 Ruby를 통해 개발된 사이트 생성기입니다.따라서 Jekyll을 설치하기 전 Ruby를 먼저 설치합니다.루비 버전은 3.2.2로 설정하고 현재 버전을 확인해보겠습니다.rbenv global 3.2.2rbenv versions system 2.6.9 2.7.0 2.7.2* 3.2.2본인이 어떤 Shell을 사용하는지 확인하기 위해 아래 명령어를 입력합니다.echo $SHELL/bin/zsh본인이 이용하는 shell에 따라서 아래 명령어를 통해 환경변수 세팅을 합니다.# zsh의 경우echo &#39;eval &quot;$(rbenv init -)&quot;&#39; &amp;gt;&amp;gt; ~/.zshrc# bash의 경우echo &#39;eval &quot;$(rbenv init -)&quot;&#39; &amp;gt;&amp;gt; ~/.bash_profile bundler 설치 및 index.html 삭제ruby에서 사용하는 패키지인 Gem의 의존성관리를 위한 의존성 관리 도구인 bundler를 설치합니다.gem install bundler이전 강의에서 만들었던 index.html을 삭제합니다.rm -f index.html Jekyll 설치 jekyll은 정적인 사이트 생성기라고 합니다.정말 신기하게도 깃허브의 공동 설립자 톰 프레스턴 워너에 의해 개발되었습니다.gem install jekylljekyll 기본 블로그를 설치합니다.# jekyll new {소스 root 디렉토리}jekyll new ./ 반드시 clone한 소스의 root 디렉토리에서 위 명령어를 입력해야 합니다.저의 경우 ~/Workspace/gun1507-test.github.io 가 되겠네요.ll을 통해 확인해 보면 기본 파일들이 있습니다.ll404.htmlGemfileGemfile.lockREADME.md_config.yml_postsabout.markdownindex.markdown 원격 저장소 push git add, commit, push를 진행합니다.git add .git commit -m &quot;add - jekyll install&quot;git push origin main 블로그 접근 및 확인 {Owner}.github.io 페이지 접속 후 index.html에 작성한 내용이 표출되는지 확인합니다. 🔥만났던 오류🔥 jekyll이 이미 존재하고 있는 경우 jekyll new ./명령어 입력 시 오류가 나는 경우가 있습니다.이 경우에는 jekyll new -f ./명령어를 입력해주세요.Conflict: /Users/Workspace/gun1507-test.github.io exists and is not empty.Ensure /Users/Workspace/gun1507-test.github.io is empty or else try again with `--force` to proceed and overwrite any files. push 이후 githug-pages 에서 Gemfile 의존성을 충족할 수 없는 경우 build 과정에서 Warning: github-pages can&#39;t satisfy your Gemfile&#39;s dependencies. 오류가 나타났습니다.github docs에서 내용을 확인할 수 있었습니다.1) 게시 소스로 사용하려는 분기가 저장소에 이미 있는지 확인하십시오.2) GitHub에서 사이트의 리포지토리로 이동합니다.3) 리포지토리 이름 아래에서 Settings 을 클릭합니다. Settings 탭이 보이지 않으면 드롭다운 메뉴를 선택한 다음 설정을 클릭합니다.4) 사이드바의 “Code and automation” 섹션에서 Pages 를 클릭합니다.이후에 Jekyll Configure을 진행합니다.workflows를 만들 수 있는데 Workflow란 Actions의 상위 개념으로 작업흐름 자동화 과정입니다.아래 내용대로 입력해주세요.name: &#39;Automatic build&#39;on: push: branches: - main paths-ignore: - .gitignore - README.md - LICENSEjobs: continuous-delivery: runs-on: ubuntu-latest steps: - name: Checkout uses: actions/checkout@v2 with: fetch-depth: 0 # for posts&#39;s lastmod - name: Setup Ruby uses: ruby/setup-ruby@v1 with: ruby-version: 2.7 bundler-cache: true - name: Deploy run: bash tools/deploy.sh 복사, 붙여넣기 후 오른쪽 위 Commit changes 를 진행합니다. github Actions에서 Setup Ruby 과정 중 오류 발생한 경우 workfolw 내용을 만든 뒤 push를 진행했지만 Error: The process &#39;/opt/hostedtoolcache/Ruby/2.7.8/x64/bin/bundle&#39; failed with exit code라는 오류가 발생했습니다.원격 저장소에서 직접 Gemfile.lock 을 삭제 후 로컬에 pull을 진행하겠습니다.git fetchgit pull origin mainGemfile.lock에 x86_64-linux 플랫폼이 없기 때문에 추가하도록 하겠습니다.bundle lock --add-platform x86_64-linux🚨이제 다시 push를 하기 전 꼭 .gitignore 파일을 수정합니다.# hidden files.*!.git*!.editorconfig!.nojekyll!.travis.yml# bundler cache_sitevendor# rubygem*.gem# npm dependenciesnode_modulespackage-lock.jsonGemfile.lock deploy 과정에서의 오류 다시 한번 push를 진행했지만 Error: Process completed with exit code라는 오류가 발생했습니다.tools/deploy.sh 가 없기 때문에 제 저장소에서 다운로드 한 이후 복붙 해주세요!tools 전체를 복붙 하고 push 하겠습니다. Sass 버전 문제로 인한 &#39;/&#39; 함수 오류 로컬에서 테스트 하기 위해 bundle install을 다시한번 진행하고 아래 명령어를 통해 로컬에서 실행시켰습니다.하지만 ‘/’ 나누기 함수를 실행할 수 없다고 합니다. 버전 문제인듯 해요.bundle exec jekyll serveDeprecation Warning: Using / for division outside of calc() is deprecated and will be removed in Dart Sass 2.0.0....수많은 해결 방법이 있겠지만 저는 ‘/’ 를 사용하지 않기로 했습니다.scss 파일의 ‘/’를 전부 ‘* 0.5’ 으로 변경합니다.npm install -g sass-migratorsass-migrator division **/*.scss" }, { "title": "따라 하다 보면 쉬운 Github Blog 만들기_1", "url": "/posts/make-devlog_1/", "categories": "Blog, jekyll", "tags": "github.io, devlog, theme, repository, chirpy", "date": "2023-06-25 22:50:13 +0900", "snippet": " 첫 번째 Step은 간단하니 따라하기 쉬워요😃github 아이디가 있다는 가정하에 진행하겠습니다. repository(저장소) 생성 Repository Name 에는 {Owner}.github.io를 입력합니다.repository 형태는 public 으로 하고, Add a README file 를 체크합니다.마지막으로 Create repository 를 합니다.저장소에 만들어진 소스를 로컬에서 다루기 위해 복사를 합니다. git clone 소스를 가져오고 싶은 곳으로 가셔서 git clone {복사한 repository url} 명령어를 입력합니다.git clone https://github.com/gun1507-test/gun1507-test.github.io.git원격 저장소에 있던 소스가 로컬에 생겼습니다.cd {repository name}` 명령어를 통해 해당 폴더로 이동합니다.cd gun1507-test.github.io index.html 생성 홈페이지에 접속 했을 때 처음 표출되는 화면입니다.html 으로 구성되어 있으며, 브라우저에서 F12를 눌렀을 때 보여지는 소스입니다.터미널에 echo &quot;Welcome my blog&quot; &amp;gt; index.html 을 입력합니다.echo &quot;Welcome my blog&quot; &amp;gt; index.html 원격 저장소 push github에 push를 하기 전에 본인의 repository와 잘 연결이 되어있는지 확인합니다.git remote -v정상적으로 연결이 되었다면 아래와 같이 표출됩니다.origin https://github.com/gun1507-test/gun1507-test.github.io.git (fetch)origin https://github.com/gun1507-test/gun1507-test.github.io.git (push)git add, commit, push를 진행합니다.git add .git commit -m &quot;add - first commit&quot;git push origin main git repository action 확인 github page &amp;gt; repository &amp;gt; Actions 경로에서 정상적으로 배포되었는지 확인 가능합니다. 블로그 접근 및 확인 {Owner}.github.io 페이지 접속 후 index.html에 작성한 내용이 표출되는지 확인합니다. 🔥만났던 오류🔥 저장소와 연동되어 있지 않은 경우 git remote -v 명령어 입력 후 repository에 연결이 되어있지 않은 경우1) git 초기화git init2) 원격 저장소 연결 : git remote set-url origin {git url}/{Owner}/{repository name}git remote set-url origin https://gun1507-test@github.com/gun1507-test/gun1507-test.github.io.git3) 연동 확인git remote -v git push 오류나는 경우 git add, git commit -m “커밋 메세지” 이후 git push를 입력했는데 아래와 같은 오류가 나타난 경우가 있습니다.git push origin mainremote: Permission to gun1507-test/gun1507-test.github.io.git denied to gun1507.fatal: unable to access &#39;https://github.com/gun1507-test/gun1507-test.github.io.git/&#39;: The requested URL returned error: 403원격 저장소에 접근 권한이 없기 때문입니다.접근 권한을 받기 위해서 토큰을 발급받아야 합니다.1) token 발급github page &amp;gt; 프로필 &amp;gt; Settings &amp;gt; Developer Settings &amp;gt; Personal Access Tokens &amp;gt; Tokens(classic) &amp;gt; Generate new token 의 경로에서 아래와 같이 입력하여 토큰을 발급합니다. 🚨한번 발급된 토큰은 다시 확인할 수 없기 때문에 꼭 저장해두세요!2) 원격 저장소 연결 : git remote set-url origin {git url}/{Owner}/{repository name}git remote set-url origin https://gun1507-test@github.com/gun1507-test/gun1507-test.github.io.git3) 패스워드 입력git push -u origin main# 패스워드 입력 시 복사한 토큰 붙여넣기Password for &#39;https://gun1507-test@github.com&#39;:" } ]
